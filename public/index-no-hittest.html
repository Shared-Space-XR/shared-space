Use this render function to replace the existing one in index.html (search for "function render(timestamp, frame)"):

```javascript
function render(timestamp, frame) {
    if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        if (hitTestSourceRequested === false) {
            session.addEventListener("end", onSessionEnded);
            
            // Show drop button when AR session starts
            if (dropButton) {
                dropButton.style.display = 'block';
                dropButton.disabled = false; // Always enabled (no surface check needed)
            }
            
            console.log('âœ“ AR session started (using camera-based placement)');
            hitTestSourceRequested = true;
        }
        
        // Place reticle at fixed distance (1.5m) in front of camera, on ground level
        camera.updateMatrixWorld();
        
        // Get camera forward direction
        const cameraDirection = new THREE.Vector3(0, 0, -1);
        cameraDirection.applyQuaternion(camera.quaternion);
        
        // Position reticle 1.5m forward from camera, at ground level
        const reticlePos = new THREE.Vector3();
        reticlePos.copy(camera.position);
        reticlePos.addScaledVector(cameraDirection, 1.5); // 1.5m forward
        reticlePos.y = camera.position.y - 1.3; // Ground level (assuming camera at eye height)
        
        reticle.position.copy(reticlePos);
        reticle.rotation.set(-Math.PI / 2, 0, 0); // Flat on ground
        reticle.visible = true;
        reticle.matrixAutoUpdate = true; // Enable auto-update
        
        // Update matrix for drop callback
        reticle.updateMatrix();
        lastReticleMatrix = reticle.matrix.clone();
    }

    // Update frustum culling for dropped objects
    camera.updateMatrixWorld();
    cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(cameraMatrix);
    
    // Capture camera snapshot for place recognition (every 10 frames to reduce cost)
    if (frame && timestamp % 10 < 16) {
        currentCameraSnapshot = captureCanvasSnapshot();
    }
    
    droppedObjects.forEach(drop => {
        if (drop.mesh) {
            drop.mesh.visible = frustum.containsPoint(drop.mesh.position);
            
            // Orient badges toward camera
            drop.mesh.traverse(child => {
                if (child.userData && child.userData.lookAtCamera) {
                    child.lookAt(camera.position);
                }
            });
        }
    });

    renderer.render(scene, camera);
}
```

Also update the onDropButtonClick function to simplify surface validation:

```javascript
function onDropButtonClick() {
    // Always allow drops - reticle shows where object will be placed
    lastReticleMatrix = reticle.matrix.clone();

    let newModel = items[itemSelectedIndex].clone();
    newModel.visible = true;
    
    // Place at reticle position
    newModel.position.copy(reticle.position);
    newModel.quaternion.copy(reticle.quaternion);
    
    let scaleFactor = modelScaleFactor[itemSelectedIndex];
    newModel.scale.set(scaleFactor, scaleFactor, scaleFactor);

    scene.add(newModel);

    // Report approximate GPS for dropped object
    const worldPos = newModel.position.clone();
    const approxGeo = localToLatLon(worldPos);
    if (approxGeo) {
        console.log('Dropped object approximate GPS:', approxGeo);
        const coords = `${approxGeo.lat.toFixed(6)}, ${approxGeo.lon.toFixed(6)}`;
        showToast(`Lat: ${approxGeo.lat.toFixed(6)}, Lon: ${approxGeo.lon.toFixed(6)}`);
        
        // Update HUD
        const hudLast = document.getElementById('hud-last');
        if (hudLast) hudLast.textContent = coords;
        
        // Capture fresh camera snapshot for this drop
        const dropSnapshot = captureCanvasSnapshot();
        console.log('Camera snapshot captured:', dropSnapshot ? 'YES' : 'NO');
        
        // Persist to backend with surface data
        persistCoordinates({
            modelIndex: itemSelectedIndex,
            lat: approxGeo.lat,
            lon: approxGeo.lon,
            alt: approxGeo.alt,
            localPos: { x: worldPos.x, y: worldPos.y, z: worldPos.z },
            quaternion: { x: newModel.quaternion.x, y: newModel.quaternion.y, z: newModel.quaternion.z, w: newModel.quaternion.w },
            hitTestMatrix: Array.from(lastReticleMatrix.elements),
            planeMetadata: extractPlaneMetadata(lastReticleMatrix),
            cameraSnapshot: dropSnapshot,
            timestamp: Date.now()
        });
    } else {
        showToast('GPS not available; showing local placement only');
    }
}
```

And update the reticle creation in init() to:

```javascript
reticle.matrixAutoUpdate = true; // CHANGE: enable auto-update for camera-based movement
```
